# -*- coding: utf-8 -*-
"""7月26日データ実験.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11PqIn3pdOwb6AT4_Y1uV4FEz_10cVgld
"""

!pip install mip
!pip install pulp
!pip install openpyxl
!pip install googlemaps pandas
!pip install googlemaps
!pip install ortools

import pandas as pd
import requests
import time
import os
import numpy as np

API_KEY = "AIzaSyB4nwVCsxX0kLRl3Mp9xnyPgaNpXitw16k"
EXCEL_PATH = "7月26日データ.xlsx"
LATLNG_CACHE_PATH = "住所キャッシュ26.csv"  #各住所の「緯度・経度」
DURATION_CACHE_PATH = "duration_cache26.csv"  #各地点ペア間の「移動時間（秒）」

# 住所→緯度経度キャッシュ
def load_latlng_cache():
    if os.path.exists(LATLNG_CACHE_PATH):
        df = pd.read_csv(LATLNG_CACHE_PATH)
        return dict(zip(df['住所'], zip(df['緯度'], df['経度'])))
    else:
        return {}

def save_latlng_cache(cache):
    df = pd.DataFrame([(addr, lat, lng) for addr, (lat, lng) in cache.items()], columns=['住所', '緯度', '経度'])
    df.to_csv(LATLNG_CACHE_PATH, index=False)

def get_latlng(address, cache):
    address = address.strip()
    if address in cache and cache[address] != (None, None):
        return cache[address]
    url = f"https://maps.googleapis.com/maps/api/geocode/json?address={requests.utils.quote(address)}&key={API_KEY}"
    for attempt in range(3):
        try:
            resp = requests.get(url, timeout=30).json()
            break
        except Exception:
            if attempt == 2:
                raise
            time.sleep(1)
    if resp.get("status") == "OK" and resp.get("results"):
        loc = resp["results"][0]["geometry"]["location"]
        latlng = (loc["lat"], loc["lng"])
    else:
        latlng = (None, None)
    cache[address] = latlng
    return latlng

# 移動時間行列キャッシュ
def load_duration_cache():
    if os.path.exists(DURATION_CACHE_PATH):
        df = pd.read_csv(DURATION_CACHE_PATH, index_col=0)
        return df
    else:
        return pd.DataFrame()

def save_duration_cache(df):
    df.to_csv(DURATION_CACHE_PATH)

def build_duration_matrix(locations, cache_df=None):
    n = len(locations)
    matrix = np.zeros((n, n), dtype=int)
    if cache_df is None or cache_df.empty:
        cache_df = pd.DataFrame(index=range(n), columns=range(n))
    for i in range(n):
        for j in range(n):
            if i == j:
                matrix[i, j] = 0
                continue
            if cache_df.loc[i, j] is not None and not pd.isna(cache_df.loc[i, j]):
                matrix[i, j] = int(cache_df.loc[i, j])
                continue
            origin = f"{locations[i][0]},{locations[i][1]}"
            destination = f"{locations[j][0]},{locations[j][1]}"
            url = f"https://maps.googleapis.com/maps/api/distancematrix/json?origins={origin}&destinations={destination}&key={API_KEY}"
            for attempt in range(3):
                try:
                    resp = requests.get(url, timeout=30).json()
                    break
                except Exception:
                    if attempt == 2:
                        raise
                    time.sleep(1)
            if resp.get("status") == "OK" and resp.get("rows"):
                el = resp["rows"][0]["elements"][0]
                if el.get("status") == "OK":
                    duration_sec = int(el["duration"]["value"])
                else:
                    duration_sec = 10**7
            else:
                duration_sec = 10**7
            matrix[i, j] = duration_sec
            cache_df.loc[i, j] = duration_sec
            time.sleep(0.1)
    save_duration_cache(cache_df)
    return matrix

# 実Excelから住所リスト自動抽出
df_addr = pd.read_excel(EXCEL_PATH, sheet_name="利用者に住所")
addresses = df_addr["住所"].tolist()

latlng_cache = load_latlng_cache()
locations = [get_latlng(addr, latlng_cache) for addr in addresses]
save_latlng_cache(latlng_cache)

duration_cache_df = load_duration_cache()
duration_matrix = build_duration_matrix(locations, duration_cache_df)

print("座標:", locations)
print("移動時間行列（秒）:\n", duration_matrix)

import pandas as pd
import numpy as np
import pulp
from collections import defaultdict
from openpyxl import Workbook
from datetime import time
import pandas as pd

# Excel読み込み（ファイル名やシート名は適宜置き換え）
df = pd.read_excel('7月26日データ.xlsx')

# ここで列名一覧を確認
print(df.columns)

# 以降に特定の列を参照する処理（例：df['開始時間']）

# ===============================
# 定数・パラメータ設定
# ===============================
MAX_TRIPS = 3
excel_path = "7月26日データ.xlsx"
output_path = "7月26日データ結果.xlsx"
duration_matrix_csv = "duration_cache26.csv"
gosa = 300  # 時間許容秒
DAY_START_SEC = 8 * 3600  # 08:00を秒に換算
BIG_M = 10**5
SOLVER_TIME_LIMIT =400  # 秒

# ===============================
# ユーティリティ関数
# ===============================
def load_duration_matrix(path):
    """CSVから距離・時間行列を読み込む"""
    df = pd.read_csv(path, index_col=0)
    dm = df.to_numpy()
    return dm

def to_seconds(t):
    """datetime.time または秒に変換"""
    return t.hour * 3600 + t.minute * 60 + t.second if isinstance(t, time) else t

# --- 表示・出力用ユーティリティ ---
def binval(v):
    """Binary-like pulp variable -> 0/1 int を返す（Noneにも安全）"""
    val = pulp.value(v)
    if val is None:
        return 0
    return 1 if val > 0.5 else 0

def intval_round(v):
    """数値変数を秒などで丸めて int にする"""
    val = pulp.value(v)
    if val is None:
        return None
    return int(round(val))

# ===============================
# Excel・CSV からデータ読み込み
# ===============================
df_user = pd.read_excel(excel_path, sheet_name="利用者に住所")
df_wc = pd.read_excel(excel_path, sheet_name="車椅子の有無")
df_car = pd.read_excel(excel_path, sheet_name="車両情報")
df_time = pd.read_excel(excel_path, sheet_name="時間帯制約")

users = [x for x in df_user["利用者名"].tolist() if x != "デポ"]
address_dict = dict(zip(df_user["利用者名"], df_user["住所"]))

n_users = len(users)
n_nodes = n_users + 1  # depot + 利用者
user_to_node = {users[i]: i+1 for i in range(n_users)}
node_to_user = {i+1: users[i] for i in range(n_users)}

# 車椅子フラグ
user_wc_flags = dict(zip(df_wc['利用者名'], df_wc['車いすの有無']))
user_wheelchair = {u: user_wc_flags.get(u, 0) for u in users}
wc_users = [u for u in users if user_wheelchair[u] == 1]

# 利用者ごとのピックアップ時間（車椅子で長め）
pickup_times = {u: 300 if user_wc_flags.get(u, 0) == 1 else 180 for u in users}

# 移動時間行列
duration_matrix = load_duration_matrix(duration_matrix_csv)

# ===============================
# 車両情報展開（MAX_TRIPS分コピー）
# ===============================
base_vehicles = []
for _, row in df_car.iterrows():
    car = {
        "車両名": str(row["車種"]),
        "通常定員": int(row["通常定員"]),
        "車椅子最大数": int(row["車椅子最大"]),
        "車椅子対応": 1 if int(row["車椅子最大"]) > 0 else 0,
        "車椅子一台あたりの人数": int(row["車椅子一台あたりの人数"]),  # ←新列
    }
    base_vehicles.append(car)
# 以降は既存のままでcopy展開

vehicles = []
for car in base_vehicles:
    for trip in range(MAX_TRIPS):
        new_car = car.copy()
        new_car["便名"] = f"{car['車両名']}_trip{trip+1}"
        new_car["trip_index"] = trip + 1
        new_car["便出発時間"] = "08:00:00"
        vehicles.append(new_car)
v = len(vehicles)

# ===============================
# MILP モデル構築
# ===============================
prob = pulp.LpProblem("VRPTW_full_fixed", pulp.LpMinimize)

# --- 変数定義 ---
used = pulp.LpVariable.dicts("used", range(v), cat="Binary")  # 便使用フラグ
x = pulp.LpVariable.dicts("x", ((i, k) for i in range(1, n_nodes) for k in range(v)), cat="Binary")  # 利用者割当
y = {}  # 経路変数
for i in range(n_nodes):
    for j in range(n_nodes):
        if i == j: continue
        for k in range(v):
            y[(i, j, k)] = pulp.LpVariable(f"y_{i}_{j}_{k}", cat="Binary")
arrival = [pulp.LpVariable(f"arrival_{i}", lowBound=0) for i in range(n_nodes)]  # 到着時刻
trip_start = [pulp.LpVariable(f"trip_start_{k}", lowBound=DAY_START_SEC) for k in range(v)]
trip_end = [pulp.LpVariable(f"trip_end_{k}", lowBound=DAY_START_SEC) for k in range(v)]
genshu = pulp.LpVariable.dicts("genshu", range(n_users), cat="Binary")  # 厳守フラグ
u_var = {}  # MTZ制約用
for i in range(1, n_nodes):
    for k in range(v):
        u_var[(i, k)] = pulp.LpVariable(f"u_{i}_{k}", lowBound=1, upBound=n_users, cat="Integer")
max_time = pulp.LpVariable("max_time", lowBound=0)  # 最大移動時間

# --- 目的関数パーツ ---
alpha = 1
beta = 1
gamma = 1000

# 車種ペナルティ
car_penalty = []
for car in vehicles:
    if "パレット" in car["車両名"]:
        car_penalty.append(1)
    elif "ラクティス" in car["車両名"]:
        car_penalty.append(1)
    elif "ハイエース" in car["車両名"]:
        car_penalty.append(5)
    else:
        car_penalty.append(1)


vehicle_penalty_term = pulp.lpSum(car_penalty[k] * used[k] for k in range(v))

# 時間厳守リスト
time_constraints = {}
for _, row in df_time.iterrows():
    name = row["利用者名"]
    strict_val = int(row["開始時間厳守"])
    start_time_val = row["開始時間"]
    time_constraints[name] = {"strict": strict_val, "time_sec": start_time_val}
strict_list = [int(time_constraints[u]['strict']) for u in users]



early_violation = [pulp.LpVariable(f"early_v_{i}", lowBound=0) for i in range(n_nodes)]
late_violation  = [pulp.LpVariable(f"late_v_{i}", lowBound=0) for i in range(n_nodes)]
early_penalty = 1000000
late_penalty  = 1000000


for i in range(1, n_nodes):
    prob += early_violation[i] >= 8*3600 - arrival[i]
    prob += late_violation[i]  >= arrival[i] - 10*3600

# 目的関数
prob += (
    beta * vehicle_penalty_term
    + max_time
    + early_penalty * pulp.lpSum(early_violation)
    + late_penalty  * pulp.lpSum(late_violation)
)


# ===============================
# 制約設定
# ===============================

# --- (1) 各利用者は1便に割り当てる ---
for i in range(1, n_nodes):
    prob += pulp.lpSum(x[(i, k)] for k in range(v)) == 1

# --- (2) 車両容量制約（通常定員・便使用フラグ） ---
for k, car in enumerate(vehicles):
    # 車椅子非利用者（wc=0）
    normal_sum = pulp.lpSum(x[(i, k)] for i in range(1, n_nodes) if user_wheelchair[node_to_user[i]] == 0)
    # 車椅子利用者（wc=1）
    wc_sum = pulp.lpSum(car["車椅子一台あたりの人数"] * x[(i, k)] for i in range(1, n_nodes) if user_wheelchair[node_to_user[i]] == 1)
    # （便使用フラグ used[k] で掛け算）
    prob += (normal_sum + wc_sum) <= car["通常定員"] * used[k]
    # 割当は便使用フラグ以下
    for i in range(1, n_nodes):
        prob += x[(i, k)] <= used[k]

# --- (3) 車椅子制約 ---
wc_idx = [i+1 for i in range(n_users) if user_wheelchair.get(users[i], 0) == 1]
for k, car in enumerate(vehicles):
    if car["車椅子最大数"] is not None:
        prob += pulp.lpSum(x[(i, k)] for i in wc_idx) <= car["車椅子最大数"]
    if not car["車椅子対応"]:
        prob += pulp.lpSum(x[(i, k)] for i in wc_idx) == 0

# --- (4) depotフロー制約（出発と帰着の整合） ---
for k in range(v):
    prob += pulp.lpSum(y[(0, j, k)] for j in range(1, n_nodes)) == pulp.lpSum(y[(i, 0, k)] for i in range(1, n_nodes))
    prob += pulp.lpSum(y[(0, j, k)] for j in range(1, n_nodes)) == used[k] * 1

# --- (5) 各ノードに来る・出るフロー = 割当 ---
for k in range(v):
    for i in range(1, n_nodes):
        prob += pulp.lpSum(y[(i, j, k)] for j in range(n_nodes) if j != i) == x[(i, k)]
        prob += pulp.lpSum(y[(j, i, k)] for j in range(n_nodes) if j != i) == x[(i, k)]

# --- (6) 到着時刻制約（depot → 利用者） ---
for k in range(v):
    for j in range(1, n_nodes):
        prob += arrival[j] >= trip_start[k] + int(duration_matrix[0, j]) - BIG_M * (1 - y[(0, j, k)])

# --- (7) 利用者間到着時刻制約（時間順序） ---
for k in range(v):
    for i in range(1, n_nodes):
        for j in range(1, n_nodes):
            if i == j: continue
            prob += arrival[j] >= arrival[i] + pickup_times[node_to_user[i]] + int(duration_matrix[i, j]) - BIG_M * (1 - y[(i, j, k)])

# --- (8) trip_end 計算 ---
for k in range(v):
   # prob += trip_end[k] >= trip_start[k]
    for i in range(1, n_nodes):
        prob += trip_end[k] >= arrival[i] + pickup_times[node_to_user[i]] + int(duration_matrix[i, 0]) - BIG_M * (1 - y[(i, 0, k)])
    #trip_end[k]<=9:00+delay(k)
# --- (9) 時間厳守制約 ---
for i in range(1, n_nodes):
    u_idx = i - 1
    uname = node_to_user[i]
    tc = time_constraints.get(uname, {"strict": 0, "time_sec": None})
    if tc["strict"] == 1 and tc["time_sec"] is not None:
        desired = to_seconds(tc["time_sec"])
        prob += arrival[i] >= desired - gosa
        prob += arrival[i] <= desired + gosa

# --- (10) MTZ サブツアー除去制約 ---???
for k in range(v):
    for i in range(1, n_nodes):
        for j in range(1, n_nodes):
            if i == j: continue
            prob += u_var[(i, k)] - u_var[(j, k)] + n_users * y[(i, j, k)] <= n_users - 1

# --- (11) 最大移動時間 ---
for k in range(v):
    prob += max_time >= trip_end[k] - trip_start[k]

# --- (12) 同一車両の便間順序制約 ---
vehicle_trip_indices = defaultdict(list)
for k, car in enumerate(vehicles):
    vehicle_trip_indices[car["車両名"]].append(k)
for car_name, trip_list in vehicle_trip_indices.items():
    trip_list_sorted = sorted(trip_list)
    for idx_ in range(len(trip_list_sorted)-1):
        k1 = trip_list_sorted[idx_]
        k2 = trip_list_sorted[idx_+1]
        prob += trip_start[k2] >= trip_end[k1] + 600
        prob += used[k1] >= used[k2]

# ===============================
# ソルバー実行
# ===============================
solver = pulp.PULP_CBC_CMD(msg=1, timeLimit=SOLVER_TIME_LIMIT, threads=4)
res = prob.solve(solver)
print("Solver status:", pulp.LpStatus[prob.status], " objective:", pulp.value(prob.objective))


# ----- 結果抽出（元コードと同じ） -----
def extract_routes_from_y(y_vars, vehicles, n_nodes):
    routes = {}
    for k in range(len(vehicles)):
        starts = [j for j in range(1, n_nodes)
                  if pulp.value(y_vars[(0, j, k)]) is not None and pulp.value(y_vars[(0, j, k)]) > 0.5]
        if not starts: continue
        route = [0]
        cur = starts[0]
        route.append(cur)
        visited = set([cur])
        while True:
            if pulp.value(y_vars.get((cur, 0, k), 0)) is not None and pulp.value(y_vars.get((cur, 0, k), 0)) > 0.5:
                route.append(0)
                break
            nexts = [j for j in range(1, n_nodes) if j != cur
                     and pulp.value(y_vars[(cur, j, k)]) is not None and pulp.value(y_vars[(cur, j, k)]) > 0.5]
            found = None
            for nx in nexts:
                if nx not in visited:
                    found = nx
                    break
            if found is None:
                if nexts: found = nexts[0]
                else:
                    route.append(0)
                    break
            route.append(found)
            visited.add(found)
            cur = found
            if len(route) > n_nodes + 5:
                route.append(0)
                break
        routes[k] = route
    return routes

routes_by_k = extract_routes_from_y(y, vehicles, n_nodes)
assign_map = {}
total_times_map = {}
last_end_times = defaultdict(lambda: DAY_START_SEC)

for k, car in enumerate(vehicles):
    if k not in routes_by_k:
        continue
    route = routes_by_k[k]
    if pulp.value(used[k]) is not None and pulp.value(used[k]) > 0.5:
        base_start = int(pulp.value(trip_start[k])) if pulp.value(trip_start[k]) is not None else DAY_START_SEC
    else:
        base_start = DAY_START_SEC
    current = max(last_end_times[car["車両名"]], base_start)
    for idx in range(1, len(route) - 1):
        prev = route[idx - 1]
        cur = route[idx]
        travel = int(duration_matrix[prev, cur])
        current += travel
        user_name = node_to_user[cur]
        arrival_val = int(pulp.value(arrival[cur])) if pulp.value(arrival[cur]) is not None else None
        desired_val = time_constraints.get(user_name, {}).get("time_sec")
        desired_sec = to_seconds(desired_val) if desired_val is not None else None

        print(
          f"user: {user_name}, arrival[{cur}]: {arrival_val}, "
          f"current: {current}, desired: {desired_sec}, gosa: {gosa}, "
          f"diff_arrival: {None if arrival_val is None or desired_sec is None else arrival_val - desired_sec}, "
          f"diff_current: {None if current is None or desired_sec is None else current - desired_sec}"
        )
        if arrival_val is not None:
            h, rem = divmod(arrival_val, 3600)
            m, s = divmod(rem, 60)
        else:
            h = m = s = 0
        assign_map[user_name] = {
            "車椅子の有無": user_wheelchair.get(user_name, 0),
            "車種": car["車両名"],
            "便名": car["便名"],
            "ピックアップ時間（時）": int(h) if h is not None else None,
            "ピックアップ時間（分）": int(m) if m is not None else None,
            "ピックアップ時間（秒）": int(s) if s is not None else None,
            "順番": f"{car['trip_index']}便目の{idx}",
            "desired_strict": time_constraints.get(user_name, {}).get("time_sec"),
            "genshu_var": int(
                pulp.value(genshu[user_to_node[user_name] - 1])
                if pulp.value(genshu[user_to_node[user_name] - 1]) is not None
                else 0
            ),
        }
        current += pickup_times[user_name]
    last_node = route[-2] if len(route) >= 2 else 0
    if last_node != 0:
        current += int(duration_matrix[last_node, 0])
    last_end_times[car["車両名"]] = current
    total_times_map[car["便名"]] = (last_end_times[car["車両名"]] - base_start) // 60

# ----- 違反チェック（元コードと同じロジック。ただし to_seconds の強化に対応） -----
violations = []
for u, info in assign_map.items():
    desired = info.get("desired_strict")
    if desired is None:
        continue
    arrival_sec = info["ピックアップ時間（時）"] * 3600 + info["ピックアップ時間（分）"] * 60 + info["ピックアップ時間（秒）"]
    # desired を int(秒) に変換する
    if isinstance(desired, time):
        desired_sec = to_seconds(desired)
    else:
        desired_sec = desired
    if desired_sec is None:
        continue
    if abs(arrival_sec - desired_sec) > gosa:
        violations.append((u, desired_sec, arrival_sec))


# ----- Excel 書き出し（元コードと同じ） -----
wb_out = Workbook()
ws_out = wb_out.active
ws_out.title = "結果"
ws_out.append([
    "利用者名", "車椅子の有無", "車種", "便名", "ピックアップ時間（時）",
    "ピックアップ時間（分）", "ピックアップ時間（秒）", "順番", "車両総移動時間（分）",
    "genshu_var", "希望時刻(秒)"
])
for u in users:
    if u in assign_map:
        d = assign_map[u]
        total_time = total_times_map.get(d["便名"], "")
        ws_out.append([
            u, d["車椅子の有無"], d["車種"], d["便名"], d["ピックアップ時間（時）"],
            d["ピックアップ時間（分）"], d["ピックアップ時間（秒）"], d["順番"], total_time,
            d.get("genshu_var", 0), d.get("desired_strict", "")
        ])
    else:
        ws_out.append([u, "未割当", "", "", "", "", "", "", "", "", ""])

ws_v = wb_out.create_sheet("違反チェック")
ws_v.append(["利用者名", "希望(秒)", "実到着(秒)", "差(秒)"])
for vinfo in violations:
    u, desired, arrival = vinfo
    ws_v.append([u, desired, arrival, arrival - desired])

ws_r = wb_out.create_sheet("便別ルート")
ws_r.append(["便名", "route_nodes (node indices)", "route_users (順序)", "便出発時刻(秒)", "便終了時刻(秒)", "便使用フラグ"])
for k, car in enumerate(vehicles):
    route = routes_by_k.get(k, [])
    route_users = [node_to_user[idx] for idx in route if idx != 0]
    trip_start_sol = int(pulp.value(trip_start[k])) if pulp.value(trip_start[k]) is not None else ""
    trip_end_sol = int(pulp.value(trip_end[k])) if pulp.value(trip_end[k]) is not None else ""
    ws_r.append([car["便名"], ",".join(map(str, route)), "->".join(route_users), trip_start_sol, trip_end_sol, int(pulp.value(used[k]) or 0)])

wb_out.save(output_path)
print("保存:", output_path)
if violations:
    print("注意: 巡回順で時間窓違反があります。Excelの'違反チェック'シートを確認！")
else:
    print("全員の到着が許容内です。")

print("終了。Solverステータス:", pulp.LpStatus[prob.status])